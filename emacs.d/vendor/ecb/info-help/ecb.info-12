This is ecb.info, produced by makeinfo version 4.2 from ecb.texi.

INFO-DIR-SECTION GNU Emacs Lisp
START-INFO-DIR-ENTRY
* ECB: (ecb).           Emacs Code Browser
END-INFO-DIR-ENTRY


File: ecb.info,  Node: Introduction,  Next: A new tree-buffer,  Prev: tree-buffer,  Up: tree-buffer

General description of tree-buffers
-----------------------------------

This subchapter is a general introduction in the main concepts of a
tree-buffer.

What is a tree-buffer?
......................

A "tree-buffer" is meant to display certain informations (e.g. a
directory-tree) in a tree-structure consisting of "tree-nodes".  Every line
in a tree-buffer displays exactly one tree-node. Each node has exactly one
parent-node and can have any arbitrary number of "children"-nodes. If a
tree-node has no children then it is called a "leaf". A tree-node contains
several "slots" wheras the most important ones are the "name",
"displayed-name" and "data". See *Note A new tree-node:: for a detailed
explanation.

The difference between a natural tree like a fir and a tree-buffer is that
the root(-node) of a tree-buffer is not visible but only its children. In the
example below the nodes parent-node-1 and parent-node-2 are the children of
the invisible root-node. Each tree-buffer has exactly one root-node which is
created automatically by `tree-buffer-create'.

If a tree-node contains at least one child it is displayed with a special
expand/collapse-symbol (see the example below). This symbol allows expanding
(rsp. collapsing) the tree-node wheras expanding means to display the
children-nodes and collapsing means to hide the childrens of a tree-node.

Here is an example of a tree-buffer:

   <root-node>  ------------------------[root-node (invisible)]
       [+] <parent-node-1>  -------.
       [-] <parent-node-2>  -------|
           [-] <expanded>  --------|
               <leaf-node-1>  -----|
               <leaf-node-2>  -----|-----[tree-nodes]
               <leaf-node-3>  -----|
               <leaf-node-4>  -----|
           [+] <collapsed>  -------´
            |
            `-----------------[expand/collapse-symbol]

In most cases an action is triggered when clicking with the mouse onto a
tree-node(1) (e.g. clicking onto "leaf-node-1" or "parent-node-1" in the
example above). Which action is triggered by which key depends on what you
specify at creation-time of the tree-buffer - see *Note A new tree-buffer::
for details.

The creation-interface of a tree-buffer allows defining special popup-menus
when clicking with the right mouse-button (of course also possible via
keyboard, see *Note Tree-buffer keybindings::) onto a tree-node (e.g. some
senseful actions possible for directory-nodes like grepping this directory or
performing version-control actions for this directory or something else).

General recipe for a tree-buffer
................................

The following sequence of tasks is the general recipe for a tree-buffer
beginning from creation and ending with the display.

1. Create the tree-buffer Creating a new tree-buffer has to be done with
   `tree-buffer-create' for non ECB-tree-buffers and with the macro
   `defecb-tree-buffer-creator' when the tree-buffer should be used as an
   ECB-tree-buffer, so it is an ECB-interactor. See *Note A new tree-buffer::
   for all details.

2. Add tree-nodes to the tree-buffer Adding nodes to the new tree-buffer
   (means make the new tree-buffer the current buffer and call
   `tree-node-new' for a new tree-node (note that a root-node for this
   tree-buffer has been autom. created by `tree-buffer-create'!). The first
   tree-node you add to a tree-buffer must have always the root-node
   (avaliable via `tree-buffer-get-root') as parent-node. The next nodes can
   have either one of the fromerly added nodes or the root-node too. All
   tree-nodes haveing the root-node as parent will be displayed at the
   toplevel of the tree-buffer. See *Note A new tree-node:: for all details.

3. Display the tree-buffer with current nodes and state When you are finished
   building up the tree-node-structure call `tree-buffer-update' to display
   the current tree-structure (again after making the tree-buffer the
   current-buffer). See *Note Updating a tree-buffer:: for all details.

*IMPORTANT*: First a call of `tree-buffer-update' updates the *display* of a
tree-buffer, means shows all the tree-nodes in an emacs-buffer! Neither
creating a tree-buffer nor adding tree-nodes display anything; this just
builds the internal tree-structure.

*IMPORTANT*: See *Note Programming special windows:: for details about
programming interactors (special windows) regardless if they were build as
tree or not. There you can find a.o. how to automatically synchronizing a
special window with the current edit-buffer.

---------- Footnotes ----------

(1) Of course using the keyboard is also possible, see *Note Tree-buffer
keybindings::.


File: ecb.info,  Node: A new tree-buffer,  Next: A new tree-node,  Prev: Introduction,  Up: tree-buffer

How to create a new tree-buffer
-------------------------------

The creator-function for a new tree-buffer depends on the fact if the new
tree-buffer should be used as an ECB-interactor or not. For a new
ECB-interactor the macro `defecb-tree-buffer-creator' has to be used,
otherwise the function `tree-buffer-create'. In the end both methods use
`tree-buffer-create' because the BODY-argument of
`defecb-tree-buffer-creator' must contain a call to this function!.

This section describes all arguments of `tree-buffer-create'.

Except the first argument NAME all arguments are key-arguments of the form
:arg-name arg-value, so for example a call looks like

   (tree-buffer-create <buffer-name> :frame <frame-object> ...).

These key-arguments (all except the first argument `NAME') can be arranged in
any arbitrary order but all of them are not-optional! The key-arg-name is
always a : followed by the lowercase version of the mentioned argument below
(e.g. `FRAME' -> :frame, `MOUSE-ACTION-TRIGGER' -> :mouse-action-trigger).

Here is a description of the arguments of `tree-buffer-create' - also
available as docstring for this function (via `C-h f'). The description below
contains also some examples for complex-arguments!

``NAME''
   Buffername of the new tree-buffer.

`FRAME'
   Frame in which the tree-buffer is displayed and valid. All key-bindings
   and interactive functions of the tree-buffer work only if called in FRAME
   otherwise nothing is done!

`MOUSE-ACTION-TRIGGER'
   When a mouse-action is triggered. Allowed values: `button-release' and
   `button-press'.

`IS-CLICK-VALID-FN'
   `tree-buffer-create' rebinds `mouse-1', `mouse-2', `RET' (and `TAB') and
   also in combination with shift and control (not with `TAB').
   IS-CLICK-VALID-FN is called first if a node or an expand-symbol is
   clicked. This function is called with five arguments:

    - mouse-button: The clicked mouse-button or RET or TAB (0 = RET or TAB, 1
      = mouse-1, 2 = mouse 2)

    - shift-pressed: Non nil if the SHIFT-key was pressed during mouse-click
      or RET.

    - control-pressed: Non nil if the CONTROL-key was pressed during
      mouse-click or RET.

    - meta-pressed: Non nil if the META-key was pressed during mouse-click or
      RET.

    - tree-buffer-name: The buffer-name of the tree-buffer where the node has
      been clicked.

   The function must return not nil iff exactly this click/hit is accepted.
   If the function returns nil then really nothing is done by the tree-buffer
   after this click/hit!

   Here is an example (call `C-h f' to see what it does) for this
   callback-function:

      (defun ecb-interpret-mouse-click (mouse-button
                                        shift-pressed
                                        control-pressed
                                        meta-pressed
                                        tree-buffer-name)
        (if (eq mouse-button 0)
            (list (if control-pressed 2 1) shift-pressed meta-pressed
                  'keyboard)
          (if (and (not (eq mouse-button 1)) (not (eq mouse-button 2)))
      	nil
            (case ecb-primary-secondary-mouse-buttons
              (mouse-1--mouse-2
               (if control-pressed
                   nil
                 (list mouse-button shift-pressed meta-pressed 'mouse)))
              (mouse-1--C-mouse-1
               (if (not (eq mouse-button 1))
                   nil
                 (list (if control-pressed 2 1) shift-pressed meta-pressed
                       'mouse)))
              (mouse-2--C-mouse-2
               (if (not (eq mouse-button 2))
                   nil
                 (list (if control-pressed 2 1) shift-pressed meta-pressed
                       'mouse)))
              (otherwise nil)))))

   This example would be passed as parameter as follows:

      (tree-buffer-create "myname"
                          :is-click-valid-fn 'ecb-interpret-mouse-click
                          ...)

`NODE-SELECTED-FN'
   Function to call if a node has been selected. This function is called with
   the following parameters:

    - node: The selected node

    - mouse-button (0 = RET, 1 = mouse-1, 2 = mouse 2)

    - shift-pressed

    - control-pressed

    - meta-pressed

    - tree-buffer-name

   For the last four arguments see the description above. This function has
   to ensure that the expandable- and expanded-state of the selected node is
   correct after returning.

   Here is an example (call `C-h f' to see what it does) for this
   callback-function:

      (defun ecb-tree-buffer-node-select-callback (node
      					     mouse-button
      					     shift-pressed
      					     control-pressed
                                                   meta-pressed
      					     tree-buffer-name)
        (let* ((ecb-button-list (ecb-interpret-mouse-click mouse-button
      						     shift-pressed
      						     control-pressed
                                                           meta-pressed
      						     tree-buffer-name))
      	 (ecb-button (nth 0 ecb-button-list))
      	 (shift-mode (nth 1 ecb-button-list))
               (meta-mode (nth 2 ecb-button-list))
               (keyboard-p (equal (nth 3 ecb-button-list) 'keyboard))
               (maximized-p (ecb-buffer-is-maximized-p tree-buffer-name)))
          ;; now we dispatch to the right action
          (when ecb-button-list
            (cond ((ecb-string= tree-buffer-name ecb-directories-buffer-name)
      	     (ecb-directory-clicked node ecb-button nil shift-mode
                                          meta-mode))
      	    ((ecb-string= tree-buffer-name ecb-sources-buffer-name)
      	     (ecb-source-clicked node ecb-button nil shift-mode
                                       meta-mode))
      	    ((ecb-string= tree-buffer-name ecb-history-buffer-name)
      	     (ecb-history-clicked node ecb-button nil shift-mode
                                        meta-mode))
      	    ((ecb-string= tree-buffer-name ecb-methods-buffer-name)
      	     (ecb-method-clicked node ecb-button nil shift-mode
                                       meta-mode))
      	    ((ecb-string= tree-buffer-name ecb-analyse-buffer-name)
      	     (ecb-analyse-node-clicked node ecb-button nil shift-mode
                                             meta-mode))
      	    (t nil)))))

   This example would be passed as parameter as follows:

      (tree-buffer-create "myname"
                          :node-selected-fn 'ecb-tree-buffer-node-select-callback
                          ...)

   *IMPORTANT*: This callback must not modify the slot EXPANDED of the passed
   node because this is done automatically by the tree-buffer-library!

`NODE-EXPANDED-FN'
   Function to call if a node is expandable, point stays onto the
   expand-symbol and node is not already expanded. This function is called
   with the following parameters:

    - node: The selected node

    - mouse-button (0 = TAB, 1 = mouse-1, 2 = mouse 2)

    - shift-pressed

    - control-pressed

    - meta-pressed

    - tree-buffer-name

   This function should add all children nodes to this node if not already
   done (if possible). This function has to ensure that the expandable- and
   expanded state of the selected node is correct after returning!

   *IMPORTANT*: This callback must not modify the slot EXPANDED of the passed
   node because this is done automatically by the tree-buffer-library!

`NODE-COLLAPSED-FN'
   Function to call if a node is expandable, point stays onto the
   expand-symbol and node is already expanded. This function is called with
   the following parameters:

    - node: The selected node

    - mouse-button (0 = TAB, 1 = mouse-1, 2 = mouse 2)

    - shift-pressed

    - control-pressed

    - meta-pressed

    - tree-buffer-name

   This function is only a callback to inform the owner/user of this
   tree-buffer that this node has been collapsed. This function must not
   modify the expandable- or expanded state of the selected node!

   Often a sensefull value for this parameter is the function `ignore'.

   *IMPORTANT*: This callback must not modify the slot EXPANDED of the passed
   node because this is done automatically by the tree-buffer-library!

`NODE-MOUSE-OVER-FN'
   Function to call when the mouse is moved over a node. This function is
   called with three arguments: NODE, WINDOW, NO-PRINT, each of them related
   to the current tree-buffer. If NO-PRINT is nil then the function must
   print the text itself in any manner. This function must always return the
   text which either is printed by the function itself or by the caller (if
   NO-PRINT is not nil). The current buffer for this function is the
   tree-buffer itself. With XEmacs this function is only called if the
   tree-buffer track-mouse mechanism is activated (see the function
   `tree-buffer-activate-follow-mouse'). With GNU Emacs >= 21 this function
   is called by the `help-echo' property added to each node.

   Here is an example (call `C-h f' to see what it does) for this
   callback-function:

      (defun ecb-mouse-over-analyse-node (node &optional window no-message
                                               click-force)
        (let ((str (when (or click-force
                             (ecb-show-minibuffer-info
                              node window
                              (car ecb-analyse-show-node-info)))
                     (if (equal (cdr ecb-analyse-show-node-info)
                                'full-info)
                         (ecb-analyse-gen-tag-info
                          (car (tree-node->data node)))
                       (tree-node->name node)))))
          (prog1 str
            (unless no-message
              (ecb-nolog-message str)))))

`MOUSE-HIGHLIGHT-FN'
   If nil then in this tree-buffer no node is highlighted when the mouse
   moves over it. If t then each node is highlighted when the mouse moves
   over it. If a function then it is called with the node as argument and if
   it returns not nil then the node will be highlighted when the mouse moves
   over it - otherwise no highlighting takes place.

`NODE-DATA-EQUAL-FN'
   Function used by the tree-buffer to test if the data of two tree-nodes are
   equal. The function is called with two args: The DATA-slots of the two
   tree-nodes (see *Note A new tree-node:: for details about the data-slots).

   Here is an example (call `C-h f' to see what it does) for this
   callback-function:

      (defun ecb-analyse-compare-node-data (left right)
        "Return not nil when LEFT and RIGHT are identical node-datas."
        (and (equal (nth 2 left) (nth 2 right))
             (ecb-compare-methods-buffer-node-data (car left)
                                                   (car right))))

   Often a suitable value for this parameter is `equal'.

`MAYBE-EMPTY-NODE-TYPES'
   Nil or a list of node-types (a node-type is an integer which must be set
   with `tree-node-new'). Nodes with one of these types are treated as empty
   if they are not expandable (i.e. they have no children) and will be
   displayed with the empty-symbol ([x]); for other nodes see next argument.

`LEAF-NODE-TYPES'
   Nil or a list of node-types (see above). Nodes with one of these types are
   treated as leafs and will be displayed with the leaf-symbol (*).

   Summary for MAYBE-EMPTY-NODE-TYPES and LEAF-NODE-TYPES:

    * Expandable nodes will always be displayed either with the open- or with
      the close-symbol.

    * Not-expandable nodes with a node-type contained in
      MAYBE-EMPTY-NODE-TYPES will be displayed with the empty-symbol.

    * Not-expandable nodes with a node-type contained in LEAF-NODE-TYPES will
      be displayed with the leaf-symbol.

    * All other nodes will be displayed with no symbol just with correct
      indentation.

`MENU-CREATOR'
   Nil or function which has to return nil or a list of conses, each cons for
   a known node-type of this tree-buffer (the node-type of a node is an
   integer). Example: ((0 . menu-for-type-0) (1 . menu-for-type-1)).  The cdr
   of a cons must be a menu in the same format `tree-buffer-create-menu'
   expects as argument - see the documentation of this function for details.
   This function gets two arguments: The name of the tree-buffer and the node
   for which a popup-menu should be opened.

   Here is an example for such a menu-creator-callback:

      (defconst ecb-analyse-nodedata-tag-with-pos 0)
      (defconst ecb-analyse-nodedata-tag-without-pos 1)
      (defconst ecb-analyse-nodedata-no-tag 2)
      
      (defconst ecb-analyse-nodetype-bucket 0)
      (defconst ecb-analyse-nodetype-context 1)
      (defconst ecb-analyse-nodetype-arguments 2)
      (defconst ecb-analyse-nodetype-completions 3)
      (defconst ecb-analyse-nodetype-localvars 4)
      (defconst ecb-analyse-nodetype-prefix 5)
      (defconst ecb-analyse-nodetype-assignee 6)
      (defconst ecb-analyse-nodetype-function 7)
      (defconst ecb-analyse-nodetype-function-arg 8)
      
      (defun ecb-analyse-create-menu (node)
        "Return a popup-menu suitable for NODE."
        (let* ((data (tree-node->data node))
               (tag-p (not (equal (nth 1 data) ecb-analyse-nodedata-no-tag)))
               (tag-with-pos-p (equal (nth 1 data)
                                      ecb-analyse-nodedata-tag-with-pos))
               (nodetype (nth 2 data)))
          (delq nil (list (if (equal nodetype ecb-analyse-nodetype-completions)
                              '(ecb-analyse-complete "Complete"))
                          (if tag-p
                              '(ecb-analyse-show-tag-info "Show tag info"))
                          (if tag-with-pos-p
                              '(ecb-analyse-jump-to-tag "Jump to tag"))))))
      
      (defun ecb-analyse-menu-creator (tree-buffer-name node)
        "Creates the popup-menus for the analyse-buffer."
        (let ((nodetype (tree-node->type node)))
          (unless (equal nodetype ecb-analyse-nodetype-bucket)
            (mapcar (function (lambda (type)
                                (cons type (ecb-analyse-create-menu node))))
                    `(,ecb-analyse-nodetype-context
                      ,ecb-analyse-nodetype-arguments
                      ,ecb-analyse-nodetype-completions
                      ,ecb-analyse-nodetype-localvars
                      ,ecb-analyse-nodetype-prefix
                      ,ecb-analyse-nodetype-assignee
                      ,ecb-analyse-nodetype-function
                      ,ecb-analyse-nodetype-function-arg)))))

   This example would be passed as parameter as follows:

      (tree-buffer-create "myname"
                          :menu-creator 'ecb-analyse-menu-creator
                          ...)

`MENU-TITLES'
   Nil or a list conses, each cons for a node-type. See MENU-CREATOR. The cdr
   of a cons must be either a string or a function which will be called with
   current node under point and must return a string which is displayed as
   the menu-title.

`MODELINE-MENU-CREATOR'
   Nil or a function which has to return nil or a menu in the same format
   `tree-buffer-create-menu' expects as argument - see the documentation of
   this function for details. This function gets one argument: The name of
   the tree-buffer. If the function returns a menu then this menu will be
   displayed when the user clicks with mouse-button 3 at the modeline of the
   tree-buffer. The menu-title will be "Tree-buffer modeline-menu".

`TRUNC-LINES'
   Should lines in this tree buffer be truncated (not nil).

`READ-ONLY'
   Should the treebuffer be read-only (not nil).

`TREE-INDENT'
   Spaces subnodes should be indented. Ignored if TREE-STYLE is `image' (see
   below).

`INCR-SEARCH-P'
   Should the incremental search be enabled in the tree-buffer. Three
   choices: `prefix', `substring', `nil'. See the command
   `tree-buffer-incremental-node-search'.

`INCR-SEARCH-ADDITIONAL-PATTERN'
   Every search-pattern is prefixed with a regexp to jump over not important
   stuff of a displayed node-name at incr. search.. This is per default:
   beginning spaces and guide characters (|`-) and all
   expand/collapse-buttons [+], [x], rsp. [-]!

   If this argument is not nil then it must be a cons-cell where car is a
   string which should be a regexp-pattern which is added to the basic-prefix
   pattern (see above) and both of them prefix the incr-search-pattern. The
   cdr is the number of subexpressions in this additoonal pattern.

`ARROW-NAVIGATION'
   If not nil then a smart navigation with arrow keys is offered:

    - Left-arrow: If node is expanded then it will be collapsed otherwise
      point jumps to the next "higher" node in the hierarchical tree (higher
      means the next higher tree-level or - if no higher level available -
      the next higher node on the same level).

    - Right-arrow: If node is not expanded then it will be expanded.

      Onto a not expandable node the horizontal arrow-keys go one character
      in the senseful correct direction.

    - Up- and down-key: Point jumps to the first character of the previous
      (up) rsp. next node (down). "First" character means either the first
      character of the expand-symbol (in case EXPAND-SYMBOL-BEFORE-P is not
      nil) or of the displayed node-name. Or with other words: The first
      non-indentation and non-guide-line (see TREE-STYLE) character of a node.

`HOR-SCROLL-STEP'
   Number of columns a hor. scroll in the tree-buffer should scroll. If not
   nil then `M-mouse-1' and `M-mouse-2' scroll left and right and also
   `M-<left-arrow>' and `M-<right-arrow>'. Ignored with XEmacs.

`DEFAULT-IMAGES-DIR'
   Full path where the default images for the tree-buffer can be found.  It
   should contain an image for every name of `tree-buffer-tree-image-names'.

`ADDITIONAL-IMAGES-DIR'
   Additional image-dir which should be searched first for images needed for
   current tree-buffer. If the image can not be found in this directory then
   DEFAULT-IMAGES-DIR is searched. If the image can't even found here the
   related ascii-symbol is used.

`IMAGE-FILE-PREFIX'
   Common prefix for all image-files for this tree-buffer, e.g. "ecb-".

`TREE-STYLE'
   There are three different styles available: Image-style (value `image'):
   Very nice and modern because image-icons are used to display the
   tree-buffer. For this style the arguments TREE-INDENT and
   EXPAND-SYMBOL-BEFORE-P have no effect.

   Ascii-style with guide-lines (value `ascii-guides') and ascii-style
   without guidelines (value `ascii-no-guides'. See *Note Tree-buffer
   styles:: for details about the tree-styles.

   Both ascii-styles are affected by the args TREE-INDENT and
   EXPAND-SYMBOL-BEFORE-P.

`ASCII-GUIDE-FACE'
   If TREE-STYLE is `ascii-guides' then this defines the face the guides
   should be displayed with.

`TYPE-FACER:'
   Nil or a list of one or more conses, each cons for a node-type (a
   node-type is an integer which must be set with `tree-node-new').  The cdr
   of a cons can be:

    - a face-symbol

    - a function-symbol which gets two arguments (see
      `tree-buffer-insert-text'). This function can do anything, but normally
      it should face a tree-node.

    - the symbol t. Then the tree-buffer assumes that the node-text is
      already faced and therefore it does not face the node, means it does
      nothing then inserting the node-text, if the tree-buffer is updated.

`EXPAND-SYMBOL-BEFORE-P'
   If not nil then the expand-symbol is displayed before the node-text.
   Ignored when TREE-STYLE is `image' and Emacs can display images.

`HIGHLIGHT-NODE-FACE'
   Face used for highlighting current selected node in this tree-buffer.

`GENERAL-FACE'
   General face in which the whole tree-buffer should be displayed.

`AFTER-CREATE-HOOK:'
   A function or a list of functions (with no arguments) called directly
   after creating the tree-buffer and defining it's local keymap. For example
   such a function can add additional key-bindings for this tree-buffer local
   keymap (use `local-set-key' for this).

   Here is an example for such a hook:

      (defun ecb-common-after-tree-buffer-create-actions ()
        "Things which should be performed after creating a tree-buffer.
      The tree-buffer is the current buffer."
        (local-set-key (kbd "C-t")
                       'ecb-toggle-do-not-leave-window-after-select)
        (if ecb-running-xemacs
            (define-key modeline-map
              '(button2up)
              'ecb-toggle-maximize-ecb-window-with-mouse)
          (local-set-key [mode-line mouse-2]
                         'ecb-toggle-maximize-ecb-window-with-mouse)))

`AFTER-UPDATE-HOOK:'
   A function or a list of functions (with no arguments) called each time
   after the tree-buffer has been updated via `tree-buffer-update'.

Here is an example how to create a tree-buffer (if you want a tree-buffer not
for ECB then just strip off the `defecb-tree-buffer-creator' and just call
`tree-buffer-create'):

   (defecb-tree-buffer-creator ecb-create-analyse-tree-buffer
       ecb-analyse-buffer-name
     "Create the tree-buffer for analyse-display."
     (tree-buffer-create
      ecb-analyse-buffer-name
      :frame ecb-frame
      :mouse-action-trigger ecb-tree-mouse-action-trigger
      :is-click-valid-fn 'ecb-interpret-mouse-click
      :node-selected-fn 'ecb-tree-buffer-node-select-callback
      :node-expanded-fn 'ecb-tree-buffer-node-expand-callback
      :node-collapsed-fn 'ecb-tree-buffer-node-collapsed-callback
      :node-mouse-over-fn 'ecb-mouse-over-analyse-node
      :mouse-highlight-fn 'ecb-analyse-node-mouse-highlighted-p
      :node-data-equal-fn 'ecb-analyse-compare-node-data
      :maybe-empty-node-types nil
      :leaf-node-types nil
      :menu-creator 'ecb-analyse-menu-creator
      :menu-titles (ecb-analyse-gen-menu-title-creator)
      :modeline-menu-creator 'ecb-common-tree-buffer-modeline-menu-creator
      :trunc-lines (ecb-member-of-symbol/value-list
                    ecb-analyse-buffer-name
                    ecb-tree-truncate-lines)
      :read-only t
      :tree-indent ecb-tree-indent
      :incr-search-p t
      :incr-search-additional-pattern nil
      :arrow-navigation ecb-tree-navigation-by-arrow
      :hor-scroll-step ecb-tree-easy-hor-scroll
      :default-images-dir (car ecb-tree-image-icons-directories)
      :additional-images-dir (ecb-member-of-symbol/value-list
                              ecb-analyse-buffer-name
                              (cdr ecb-tree-image-icons-directories)
                              'car 'cdr)
      :image-file-prefix "ecb-"
      :tree-style ecb-tree-buffer-style
      :ascii-guide-face ecb-tree-guide-line-face
      :type-facer nil
      :expand-symbol-before-p ecb-tree-expand-symbol-before
      :highlight-node-face ecb-analyse-face
      :general-face ecb-analyse-general-face
      :after-create-hook (append
                          (list (lambda ()
                                  (ecb-common-after-create-actions)))
                          ecb-common-tree-buffer-after-create-hook
                          ecb-analyse-buffer-after-create-hook)
      :after-update-hook nil))


File: ecb.info,  Node: A new tree-node,  Next: Updating a tree-buffer,  Prev: A new tree-buffer,  Up: tree-buffer

How to create a new tree-node
-----------------------------

When a new tree-buffer has been created, then the most senseful
programming-task is adding some tree-nodes to it.

Content of a tree-node
......................

A tree-node is an object which stores in special "slots" several data
necessary to link the node with other nodes, to display the node and to hold
some associated node-data (e.g. a tag created by the semantic-library).

A tree-node can have the following slots:

`NAME'
   The name of the node. Regardless how the node is displayed; see
   SHRINK-NAME and DISPLAYED-NAME.

`TYPE'
   The type of the node; must currently be an interger! The type is used to
   classify the nodes, so for example all nodes of a certain type can display
   the same popup-menu - see `tree-buffer-create' or *Note A new
   tree-buffer:: which parts of a tree-buffer are distinguished by node-types.

`DATA'
   The data of the node; This can be any arbitrary emacs-lisp-object.  This
   slots holds that data asscociated with the node and represented by the
   node in the tree-buffer. Example: Assume a tree-buffer displaying a
   directory-tree where each node just displays as its name the name of
   (sub)directories, but not the full path. The full path is stored in the
   DATA-slot of a node so when clicking onto this node the asscociated
   directory can be open for example in a dired-buffer.

`EXPANDABLE'
   If not nil then the node is expandable means it has children.

`EXPANDED'
   If not nil then the node is currently expanded, means its children are
   visible in the tree-buffers as subnodes of the node.

`PARENT'
   The parent tree-node. This is the link to the father (rsp. mother ;-) of
   the node. It must be a object of type tree-node!

`CHILDREN'
   List of children tree-nodes. They must be all objects of type tree-node!

`SHRINK-NAME'
   Decides if the NAME can be shortened when displayed in a narrow tree
   buffer window. The following values are valid:

    - `beginning': The NAME is truncated at the beginning so the end is always
      visible.

    - `end': The NAME is truncated at the end. If the tree-node is EXPANDABLE
      the name is truncated so that the expand symbol is visible.

    - `nil': The NAME is never truncated. In this case DISPLAYED-NAME is
      equal to NAME.

`INDENTSTR'
   Containes the full indentation-string for the node. So a single node can
   easily be redrawn.

`DISPLAYED-NAME'
   Contains the current displayed name of the node. The displayed name can be
   different from the NAME according to the value of SHRINK-NAME.

Creating a new tree-node and adding it to the tree
..................................................

A new tree-node has to be created with the function `tree-node-new'. This
"constructor" accepts the following parameter: NAME, TYPE, DATA,
NOT-EXPANDABLE, PARENT and SHRINK-NAME.

For all parameters except NOT-EXPANDABLE the description is available in the
slot-description in the section above. If NOT-EXPANDABLE is set to not nil
then the slot EXPANDABLE will be set to `nil'; otherwise to `t'.

`tree-node-new' returns a new tree-node.

The new node can either being added implicitely to the tree via the optional
PARENT-parameter when calling `tree-buffer-new' or explicitely by first
creating the new node without setting the parent-node but later setting the
parent-node via the according accessor (see next section below). Children
should only being added with `tree-node-add-children' - see next section.

Accessing the slots of a tree-node
..................................

The section above shows which slots a tree-node have.

A slot with name XXX is getable with the following piece of code:

   (tree-node->xxx <a tree node>)

Here is an example how to get the value of the slot DATA:

   (tree-node->data <a tree node>)

A slot with name XXX is setable with the following piece of code:

   (setf (tree-node->xxx <a tree node>) <new value>)

Again an example with slot DATA which sets this slot to the string
"~/a_subdir_of_HOME":

   (setf (tree-node->data <a tree node>) "~/a_subdir_of_HOME")

*IMPORTANT*: Adding new children to a node should always being done with the
function `tree-node-add-children' because this functions encapsulates all the
necessary stuff needed to add children to a node (mainly adding the children
itself and setting the node itself as parent for every children).

See *Note The tree-buffer-API:: for the rest of the API available for
tree-nodes.


File: ecb.info,  Node: Updating a tree-buffer,  Next: Tree-buffer keybindings,  Prev: A new tree-node,  Up: tree-buffer

How to update a tree-buffer-display after changes
-------------------------------------------------

When finished with adding tree-nodes to the tree-structure you mostly want to
display the current tree and its state in the buffer/window so a user can see
the current tree and can use it.

Threre are two ways to update a tree-buffer for display:

1. Updating the whole tree-buffer:

   This is the most used way to update the tree-buffer display. It's quite
   simple, just call `tree-buffer-update'. In most cases you want to call it
   without arguments.

   If you want to display a certain expanded node and as much as possible
   subnodes of this node then pass this node-object as first argument to
   `tree-buffer-update'.

   If you do not have the need to display a completely new tree-structure but
   you want only to display a previously cached display-state then pass this
   cached-state as second argument to `tree-buffer-update'. See the
   documentation of this function and also *Note Tree-buffer How to:: for a
   detailled description how to do this.

2. Updating only a single node of the tree-buffer:

   Sometimes it can be useful to update only exactly one special node, e.g.
   when your application codes some node-state in the displayed node-name
   (e.g. ECB displays the version-control state of a file as part of the
   related node-name) then it is necessary to update only this node if the
   state has changed.

   This can be done with the function `tree-buffer-update-node'. For this
   function the mentioning in this section can be misleading because this
   function can not only update the node-display but in general the slots
   NAME, SHRINK-NAME, TYPE, DATA and EXPANDABLE. Do `C-h f' to see the
   documentation of this function for all details!



File: ecb.info,  Node: Tree-buffer keybindings,  Next: The tree-buffer-API,  Prev: Updating a tree-buffer,  Up: tree-buffer

Default and customizable keybindings of a tree-buffer
-----------------------------------------------------

When creating a tree-buffer with `tree-buffer-create' the following keys will
automatically being bound:

`delete'
`backspace'
`home'
`end'
`a' (and each other key bound to `self-insert-command')
   All of these keys are bound to the command
   `tree-buffer-incremental-node-search' if the argument INCR-SEARCH-P of
   `tree-buffer-create' was set to not nil.  See the documentation of
   `tree-buffer-incremental-node-search' for all details.

`RET'
`C-RET'
`S-RET'
`M-RET'
`C-S-RET'
`mouse-1'
`C-mouse-1'
`S-mouse-1'
`M-mouse-1'
`mouse-2'
`C-mouse-2'
`S-mouse-2'
`M-mouse-2'
   All these keys are bound to an action-dispatcher which works as follows:

   If the callback-function in slot IS-CLICK-VALID-FN of the tree-buffer
   (*note A new tree-buffer::) returns nil then nothing is done.

   If either `RET' has been hitted or point is as the node-name (i.e.  the
   user has clicked with the mouse-1/2 at the node-name) then the
   callback-function in slot NODE-SELECTED-FN is called with the needed
   arguments (*note A new tree-buffer::).

   If point is at the expand/collape-button then depending on the
   expansion-state of the node either the callback in slot NODE-EXPANDED-FN
   or NODE-COLLAPSED-FN is called (for parameters see again *Note A new
   tree-buffer::).

   *IMPORTANT*: None of these callbacks must modify the slot EXPANDED of the
   passed node because this is done automatically by the action-dispatcher!

   At the end the dispatcher updates the tree-buffer-display with optimized
   display of the clicked/selected node - see *Note Updating a tree-buffer::.
   This means `tree-buffer-update' is called with that node as argument.

`TAB'
   Depending on the expansion-state of the node either the callback in slot
   NODE-EXPANDED-FN or NODE-COLLAPSED-FN is called (for parameters see again
   *Note A new tree-buffer::).

   *IMPORTANT*: None of these callbacks must modify the slot EXPANDED of the
   passed node because this is done automatically by the action-dispatcher!

   At the end the the tree-buffer-display is updated with optimized display
   of the clicked/selected node - see *Note Updating a tree-buffer::. This
   means `tree-buffer-update' is called with that node as argument.

`mouse-3'
   Activates the popup-menu for the current tree-buffer for current node-type
   (if defined). See *Note A new tree-buffer:: at argument MENU-CREATOR and
   MENU-TITLES. These callbacks are called for getting the menu and the
   menu-title.

`modeline-mouse-3'
   Activates the popup-menu for the modeline of the current tree-buffer (if
   defined). See *Note A new tree-buffer:: at argument MODELINE-MENU-CREATOR.
   This callback is called for getting the modeline-menu.

`M-m'
   This key is bound to the command `tree-buffer-show-node-menu-keyboard':
   Activates the popup-menu of current tree-buffer for current node-type via
   keyboard. If called with a prefix-arg then the library `tmm.el' is used for
   displaying the popup-menu - ignored with XEmacs.

`<up>'
`<down>'
`<left>'
`<right>'
   These keys are bound to the command `tree-buffer-arrow-pressed' which
   implements the smart arrow-key-navigation described in *Note A new
   tree-buffer:: at argument ARROW-NAVIGATION.

In addition to these automatically bound keys you can add further keybindings
to the local-keymap of the tree-buffer with the parameter AFTER-CREATE-HOOK
of `tree-buffer-create'. See *Note A new tree-buffer:: for an example which
binds `C-t' in this hook.


File: ecb.info,  Node: The tree-buffer-API,  Next: Do not with tree-buffer,  Prev: Tree-buffer keybindings,  Up: tree-buffer

All functions available for tree-buffers and tree-nodes
-------------------------------------------------------

This chapter lists the complete AI available for tree-buffers and tree-nodes.

*IMPORTANT*: These are the only functions and macros of tree-buffer.el you
are allowed to use for programming with tree-buffers and tree-nodes. If you
use other - not here listed - functions, macros or variables of
tree-buffer.el then you run the risk of unwanted side-effects or
program-behaviors!

The API for a tree-buffer:
..........................

See the documentation of these functions (e.g. via `C-h f') to get the
details how to use it.

 * `tree-buffer-add-image-icon-maybe'

 * `tree-buffer-find-image'

 * `tree-buffer-create'(1)

 * `tree-buffer-defpopup-command'

 * `tree-buffer-destroy'(2)

 * `tree-buffer-empty-p'

 * `tree-buffer-expand-node'

 * `tree-buffer-get-node-at-point'

 * `tree-buffer-node-data-equal-p'

 * `tree-buffer-recenter'

 * `tree-buffer-highlight-node-data'

 * `tree-buffer-remove-highlight'

 * `tree-buffer-remove-node'

 * `tree-buffer-clear-tree'

 * `tree-buffer-displayed-nodes-copy'

 * `tree-buffer-search-displayed-node-list'

 * `tree-buffer-number-of-displayed-nodes'

 * `tree-buffer-get-data-store'

 * `tree-buffer-set-data-store'

 * `tree-buffer-get-root'

 * `tree-buffer-set-root'

 * `tree-buffer-update'

 * `tree-buffer-update-node'

The API for a tree-node
.......................

See the documentation of these functions (e.g. via `C-h f') to get the
details how to use it.

 * `tree-node-add-children'

 * `tree-node-linelength'

 * `tree-node-new'

 * `tree-node-new-root'

 * `tree-node-remove-child'

 * `tree-node-remove-child-by-data'

 * `tree-node-find-child-by-data'

 * `tree-node-find-child-by-name'

 * `tree-node-search-subtree-by-data'

 * `tree-node-sort-children'

 * `tree-node-toggle-expanded'

In addition to these functions the tree-node API contains all accessors for a
tree-node which are described in *Note A new tree-node::.

---------- Footnotes ----------

(1) If the tree-buffer should be used by ECB then you must use
`defecb-tree-buffer-creator' - see the documentation!

(2) Not needed when `defecb-tree-buffer-creator' has been used for creation.


File: ecb.info,  Node: Do not with tree-buffer,  Next: Tree-buffer How to,  Prev: The tree-buffer-API,  Up: tree-buffer

Things which are strictly forbidden
-----------------------------------

Variable `tree-buffers': Only for internal use! It contains all tree-buffers
of current Emacs-instance, means *all* tree-buffers of *all* applications
which uses currently tree-buffers. Every application must store its own
collection of tree-buffers in an own variable! For example: ECB stores its
tree-buffer set in `ecb-tree-buffers'!

Variable `tree-buffer-displayed-nodes': Only for internal use!  Contains all
the current visible nodes of current tree-buffer in top-to-bottom order. This
variable is buffer-local in each tree-buffer! Do not use it directly! When
you want to cache the current display, then see *Note Tree-buffer How to::
how to do this.

*IMPORTANT*: An application may only use the API tree-buffer.el provides but
no internal variables - see *Note The tree-buffer-API::!


File: ecb.info,  Node: Tree-buffer How to,  Prev: Do not with tree-buffer,  Up: tree-buffer

How to deal with certain programming-requirements
-------------------------------------------------

This chapter describes in detail how to solve certain programming-challenges
with tree-buffers.

Caching the current tree-buffer display
.......................................

Sometimes it can be useful or important to cache the current display of a
tree-buffer and display later exactly this cached display-state.  Here is how
to do this:

1. Caching the display: You have to do two tasks: First store the current
   internal structure of the tree-buffer; you must do this with the function
   `tree-buffer-displayed-nodes-copy'. Then store the buffer-contents of that
   tree-buffer you want to cache; you can do this for example with
   `buffer-substring'. For both tasks you must make the tree-buffer the
   current-buffer.

2. Displaying a previous tree-buffer-cache: Make the tree-buffer the current
   buffer, call `tree-buffer-update' and pass as second argument CONTENT the
   data you have stored in step 1. See the documentation of
   `tree-buffer-update' for details.

   Here is an example:

      (tree-buffer-update
        nil
        (cons (nth 2 cache-elem) ;; the stored buffer-string
              (nth 1 cache-elem) ;; the stored tree-structure
        )))


File: ecb.info,  Node: Adviced functions,  Next: The layout-engine,  Prev: tree-buffer,  Up: Elisp programming

How to deal with the adviced window-functions
=============================================

ECB offers three macros for packages which work during an activated ECB. They
allow an easy temporally(1) usage of either all original-functions, all
adviced functions or only some adviced functions:

 - `ecb-with-original-functions'

 - `ecb-with-adviced-functions'

 - `ecb-with-some-adviced-functions'

For a detailed explanation of each macro read the documentation with
`describe-function'!

---------- Footnotes ----------

(1) I.e. regardless of the settings in `ecb-advice-window-functions'!


File: ecb.info,  Node: The layout-engine,  Prev: Adviced functions,  Up: Elisp programming

How to program new layouts and new special windows
==================================================

There are two aspects concerning this topic:

1. Programming a new layout which contains several special ECB-windows like
   directories, sources, methods, history or other special windows and
   arranging them in a new outline.

2. Creating complete new special windows (e.g. a local-variable window for a
   graphical debugger like JDEbug of JDEE), adding them to a layout and
   synchronizing them with the current active edit-window.

The former one covers merely the layout-programming aspect which is explained
in the first subsection of this chapter whereas the latter one covers all
aspects of creating new special windows and what is necessary to synchronize
it with the current active edit-window of ECB. This is explained in the
second subsection which will refers to the first subsection.

* Menu:

* Programming a new layout::    How to program a new layout
* Programming special windows:: Aspects of programming special windows
* Possible layout-outlines::    The wide range of possible layouts
* The layout-engine API::       The complete layout-engine API

